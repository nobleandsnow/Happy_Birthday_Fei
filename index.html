<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- åŠ å…¥ viewport-fit=cover ä»¥é©æ‡‰ iPhone ç€æµ·å± -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>é˜¿å¦ƒç”Ÿæ—¥å¿«æ¨‚ï¼</title>
    <!-- å¼•å…¥åœ“æ½¤å­—é«” -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050510; 
            font-family: 'Microsoft JhengHei', sans-serif; 
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
            -webkit-user-select: none; /* iOS ç¦æ­¢é¸å–æ–‡å­— */
            user-select: none;
            -webkit-touch-callout: none; /* iOS ç¦æ­¢é•·æŒ‰è·³å‡ºé¸å–® */
        }
        #canvas-container { width: 100%; height: 100vh; display: block; cursor: move; }
        
        /* æ¨™é¡Œèˆ‡é®ç½©å±¤ */
        #title-overlay { position: absolute; top: 15%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; pointer-events: none; z-index: 10; width: 100%; }
        /* é€²å…¥è›‹ç³•è½‰å ´ç‚ºæ·ºç°è‰² (æ¨¡æ“¬é–ƒå…‰) */
        #transition-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #e6e6e6; opacity: 0; pointer-events: none; z-index: 100; transition: opacity 1.2s ease-in-out; }
        #floating-text { position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; font-weight: 900; text-shadow: 0 0 5px #000; opacity: 0; pointer-events: none; z-index: 150; white-space: nowrap; transition: opacity 0.3s, top 0.3s ease-out; }
        #floating-text.show { opacity: 1; top: 40%; }

        /* ä¸»æ¨™é¡Œæ¨£å¼ */
        h1 { font-family: 'Nunito', sans-serif; font-size: 3.5rem; margin: 0; font-weight: 800; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); transition: all 0.5s ease; }
        h1.neon-active {
            text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px #ff1493, 0 0 82px #ff1493, 0 0 92px #ff1493, 0 0 102px #ff1493, 0 0 151px #ff1493;
            animation: neon-pulse 1.5s ease-in-out infinite alternate;
        }
        @keyframes neon-pulse {
            from { text-shadow: 0 0 4px #fff, 0 0 10px #fff, 0 0 18px #fff, 0 0 38px #ff1493, 0 0 73px #ff1493, 0 0 80px #ff1493, 0 0 94px #ff1493, 0 0 140px #ff1493; }
            to { text-shadow: 0 0 2px #fff, 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #ff1493, 0 0 35px #ff1493, 0 0 40px #ff1493, 0 0 50px #ff1493, 0 0 75px #ff1493; }
        }
        
        /* å‰¯æ¨™é¡Œæ¨£å¼ - åˆå§‹ç‹€æ…‹ç‚ºå¯è¦‹ */
        #main-subtitle { 
            font-size: 1.2rem; 
            color: rgba(255, 255, 255, 0.7); 
            font-weight: 600; 
            letter-spacing: 1px; 
            transition: opacity 0.3s ease; /* åŠ å¿«æ¶ˆå¤±é€Ÿåº¦ */
            opacity: 1; /* åˆå§‹è¨­ç‚ºå¯è¦‹ */
            min-height: 1.5em; /* ä½”ä½é˜²æ­¢è·³å‹• */
        }
        
        /* é‡å•ŸæŒ‰éˆ•å®¹å™¨å®šä½ */
        #btn-replay-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
        }
        /* æ¡Œé¢ç‰ˆç§»è‡³å³ä¸‹è§’ */
        @media (min-width: 768px) {
            #btn-replay-container {
                left: auto;
                right: 20px;
                transform: none;
            }
        }
        
        /* é‡å•ŸæŒ‰éˆ•æ¨£å¼ */
        #btn-replay {
            background-color: #ff55aa; /* é®®è±”çš„æ¡ƒç´… */
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 10px rgba(255, 85, 170, 0.4);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            line-height: 1;
            pointer-events: auto; /* ç¢ºä¿å¯ä»¥é»æ“Š */
            margin-left: 0;
        }
        #btn-replay:hover {
            background-color: #ff77bb;
            transform: translateY(-1px);
            box-shadow: 0 6px 15px rgba(255, 85, 170, 0.6);
        }
        #btn-replay:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(255, 85, 170, 0.4);
        }

        /* å½ˆçª—æ¨£å¼ (ä¿æŒåŸæ¨£å¼) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 200; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-box { position: relative; background-color: #fff; padding: 2rem; border-radius: 15px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 340px; max-width: 85%; min-height: 180px; display: flex; flex-direction: column; justify-content: center; align-items: center; transform: scale(0.8); transition: transform 0.3s; overflow: hidden; }
        .modal-overlay.active .modal-box { transform: scale(1); }
        .modal-text { color: #333; font-size: 1.3rem; font-weight: bold; margin-bottom: 25px; line-height: 1.5; width: 100%; }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; width: 100%; }
        .btn { padding: 10px 20px; font-size: 1rem; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; min-width: 80px; transition: transform 0.1s; }
        .btn:active { transform: scale(0.95); }
        .btn-confirm { background-color: #81D8D0; color: #fff; }
        .btn-cancel { background-color: #f0f0f0; color: #555; }
        .btn-danger { background-color: #ff3333; color: #fff; }
        .value-badge { position: absolute; top: 15px; right: -30px; background-color: #ff3333; color: #fff; font-size: 0.8rem; padding: 5px 30px; transform: rotate(45deg); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .modal-overlay.click-anywhere { cursor: pointer; }

        /* 404 ç‰¹æ®Šæ¨£å¼ */
        .modal-box-error { background-color: #1a051a; border: 2px solid #ff0055; box-shadow: 0 0 20px rgba(255, 0, 85, 0.5); background-image: linear-gradient(rgba(255,0,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255,0,255,0.1) 1px, transparent 1px); background-size: 20px 20px; }
        .text-404 { color: #ff3333; font-family: monospace; font-size: 3.5rem; font-weight: 900; margin-bottom: 5px; line-height: 1; text-shadow: 0 0 5px #ff0000, 0 0 10px #8b0000; }
        .text-404-sub { color: #ff9999; font-family: monospace; font-size: 0.8rem; margin-bottom: 20px; text-shadow: 0 0 2px #ff0000; }
        
        /* ä¿®å¾©å½ˆçª— */
        #btn-repair-complete, #repair-subtext { display: none; }
        #repair-subtext { font-size: 0.9rem; color: #4caf50; margin-bottom: 15px; font-weight: bold; }
        
        @media (max-width: 600px) { h1 { font-size: 2.2rem; } .text-404 { font-size: 2.5rem; } }
    </style>
</head>
<body>
<!-- éŸ³æ¨‚æ’­æ”¾å™¨ -->
<!-- ç‚ºäº†ç¢ºä¿åœ¨ iPhone ä¸Šèƒ½æ’­æ”¾ï¼Œå¿…é ˆä½¿ç”¨ preload="auto" -->
<audio id="bgm" preload="auto">
    <source src="https://cdn.discordapp.com/attachments/1028289358429704202/1447846555842248764/happy_birthday_song.mp3?ex=69391bae&is=6937ca2e&hm=809a5cff7c70a3efa2d9ac8fa08ebfdbc412bcde77be3c15dad7ad8c7e52c641&" type="audio/mp3">
</audio>

<div id="transition-overlay"></div>
<div id="floating-text"></div>
<!-- èª¿æ•´æ¨™é¡Œå€åŸŸ -->
<div id="title-overlay">
    <h1 id="main-title">ç¦®ç‰©?</h1>
    <div id="main-subtitle-group" style="display: flex; justify-content: center; align-items: center; margin-top: 10px; pointer-events: none;">
        <!-- å‰¯æ¨™é¡Œå…ƒç´ ï¼šåˆå§‹é¡¯ç¤ºæç¤º -->
        <div id="main-subtitle">é»æ“Šç¦®ç‰©ç›’...?</div>
    </div>
</div>
<div id="canvas-container"></div>

<!-- æŒ‰éˆ•å®¹å™¨ç¨ç«‹ -->
<div id="btn-replay-container">
    <button id="btn-replay" style="display:none;" onclick="restartGameSoft()">
        å†ç©ä¸€æ¬¡
    </button>
</div>

<!-- å½ˆçª—ç¾¤çµ„ -->
<div id="modal-1" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">
            èŠ±è²»30å…ƒè§£é–è¶…å€¼æ¬Šé™ï¼Ÿ<br>
            <span style="font-size:0.9em;color:#888;text-decoration:line-through;">ï¼ˆåŸåƒ¹99999å…ƒï¼‰</span>
        </p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="showModalA()">ç•¶ç„¶ï¼</button>
            <button class="btn btn-cancel" onclick="showModal2()">ç•¶ç„¶...ä¸è¦ã€‚</button>
        </div>
    </div>
</div>

<div id="modal-2" class="modal-overlay">
    <div class="modal-box">
        <div class="value-badge">3333%è¶…å€¼</div>
        <p class="modal-text">ä¸ç„¶0.99ç¾å…ƒå°±å¥½ï¼ˆï¼Ÿï¼‰</p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="showModalB()">å“‡å•ŠçœŸåˆ’ç®—ï¼</button>
            <button class="btn btn-cancel" onclick="showModal3()">...</button>
        </div>
    </div>
</div>

<div id="modal-3" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">
            ä¸ç„¶0.0001å°±å¥½<br>
            <span style="font-size:0.9em;color:#888;">æ‹œè¨—å˜›QwQ</span>
        </p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="showModalC()">å¥½å•¦...</button>
            <button class="btn btn-cancel" onclick="showModal4()">æ»¾ã€‚</button>
        </div>
    </div>
</div>

<div id="modal-404" class="modal-overlay">
    <div class="modal-box modal-box-error">
        <p class="text-404">404 ERROR!</p>
        <p class="text-404-sub">ReferenceError: function() is not defined</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModalY()">ï¼ˆï¼Ÿï¼‰</button>
        </div>
    </div>
</div>

<div id="modal-y" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">æ€¥æ€¥æ€¥æ€¥ä»€éº¼æ€¥å˜›ï¼Œè¶•æŠ•èƒå•Šï¼Ÿç¨‹å¼éƒ½å£æ‰äº†å•¦ï¼</p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="showModalZ()">å‡¶å‡¶å‡¶å‡¶å±å‡¶ï¼Ÿå°±åˆ¥è®“æˆ‘ä¸‹æ¬¡è¦‹åˆ°ä½ ğŸ˜¡</button>
        </div>
    </div>
</div>

<div id="modal-z" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">å°...å°ä¸èµ·...éƒ½æ˜¯æˆ‘çš„éŒ¯...æˆ‘ä¸€å€‹äººå»è§’è½ä¿®å¾©ç¨‹å¼...å—šå—šå—šå—šå—šå—šğŸ¥¹</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showRepairModal()">......</button>
        </div>
    </div>
</div>

<div id="modal-repair" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text" id="repair-text">ä¿®å¾©ä¸­.</p>
        <p id="repair-subtext">å·²ä¿®å¾©1211è™•éŒ¯èª¤</p>
        <div class="modal-buttons">
            <button id="btn-repair-complete" class="btn btn-confirm" onclick="confirmPayment()">åŸç¥ï¼ˆï¼Ÿï¼‰å•Ÿå‹•ï¼</button>
        </div>
    </div>
</div>

<div id="modal-a" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">è¬è¬å¦³çš„30æ­å…ƒğŸ˜˜ï¼</p>
        <div class="modal-buttons">
            <button class="btn btn-danger" onclick="showModalX()">é ï¼é€€éŒ¢ï¼</button>
        </div>
    </div>
</div>

<div id="modal-b" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">0.99ç¾å…ƒèˆ‡30å°å¹£æœ‰æœ¬è³ªä¸Šçš„å·®åˆ¥å—0.0</p>
        <div class="modal-buttons">
            <button class="btn btn-danger" onclick="showModalX()">é ï¼é€€éŒ¢ï¼</button>
        </div>
    </div>
</div>

<div id="modal-c" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">æ¯”ç‰¹å¹£ï¼Œé¢äº¤ï¼Œè¬è¬å¦³ï¼â¤ï¸</p>
        <div class="modal-buttons">
            <button class="btn btn-danger" onclick="showModalX()">é ï¼é€€éŒ¢ï¼</button>
        </div>
    </div>
</div>

<div id="modal-x" class="modal-overlay click-anywhere" onclick="unlockPermissionSequence()">
    <div class="modal-box">
        <p class="modal-text">æ¬¸å˜¿å˜¿ä¾†ä¸åŠå›‰</p>
    </div>
</div>

<div id="modal-4" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">0å…ƒï¼ŸğŸ¥º</p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="showModal5()">æˆäº¤ï¼</button>
            <button class="btn btn-confirm" onclick="showModal5()">å¥½</button>
        </div>
    </div>
</div>

<div id="modal-5" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">å“ˆå“ˆå“ˆä½ ä¸Šç•¶äº†ï¼Œå‰›å‰›çš„å¹£å€¼æ˜¯æ¯”ç‰¹å¹£ï¼</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModal6()">ï¼Ÿ</button>
        </div>
    </div>
</div>

<div id="modal-6" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">ç®—ä¸Šæ¯”ç‰¹å¹£åŒ¯ç‡ï¼Œé€™æ¨£ç¸½å…±æ˜¯...0</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModal7()">...</button>
        </div>
    </div>
</div>

<div id="modal-7" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">...</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModal8()">...</button>
        </div>
    </div>
</div>

<div id="modal-8" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">......</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModal9()">......</button>
        </div>
    </div>
</div>

<div id="modal-9" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">ã€‚ã€‚ã€‚</p>
        <div class="modal-buttons">
            <button class="btn btn-cancel" onclick="showModal10()">ã€‚ã€‚ã€‚</button>
        </div>
    </div>
</div>

<div id="modal-10" class="modal-overlay click-anywhere" onclick="showModal11()">
    <div class="modal-box">
        <p class="modal-text">é€™ç ´ç¨‹å¼èª°å¯«çš„...</p>
    </div>
</div>

<div id="modal-11" class="modal-overlay click-anywhere" onclick="showModal12()">
    <div class="modal-box">
        <p class="modal-text">
            æ„›èª°èª°ï¼Œæˆ‘ä¸å¹¹äº†<br>
            <span style="font-size:0.9em;color:#888;">æˆ‘åˆä¸æ˜¯ä¸€å¤©åªè³º7ç¾åˆ†çš„è©é¨™ä»”</span>
        </p>
    </div>
</div>

<div id="modal-12" class="modal-overlay">
    <div class="modal-box">
        <p class="modal-text">0æ¯”ç‰¹å¹£ï¼Œé¢äº¤ï¼Œè¬è¬</p>
        <div class="modal-buttons">
            <button class="btn btn-confirm" onclick="confirmPayment()">æ²’å®Œæ²’äº†äº†æ˜¯å§ï¼ˆ</button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
<script>
// ä½¿ç”¨ IIFE (ç«‹å³èª¿ç”¨å‡½å¼è¡¨é”å¼) åŒ…è£¹æ‰€æœ‰ç¨‹å¼ç¢¼ï¼Œé¿å…æ±¡æŸ“å…¨åŸŸç¯„åœ
(function () {
    "use strict";

    // ç…™ç«åƒæ•¸
    const FIREWORK_POOL_SIZE = 80;
    const FIREWORK_CYCLE_DURATION = 1500;
    const FLOATING_TEXT_DURATION = 1200;

    // ç”Ÿæ—¥å¿«æ¨‚å‰¯æ¨™é¡Œåº«
    const SUBTITLES = [
        "(æˆ–è¨±é‚„æœ‰é©šå–œï¼Ÿ)", // å¿…é ˆæ˜¯ç¬¬ä¸€å€‹ï¼Œä½œç‚ºé¦–æ¬¡é€²å…¥çš„æ¨™é¡Œ
        "(çµ¦æˆ‘äº”æ˜Ÿå¥½è©•è¬è¬å¦³ï¼)", "(å—šå—šæˆ‘ã„‰è²¼åœ–è¦æ²’äº†)",
        "(æœ‰å€‹ç™½ç™¡å¿˜è¨˜æ”¾å‰¯æ¨™é¡Œäº†0.0)", "(20051211ç¾å…ƒè§£é–å®Œæ•´ç‰ˆï¼)", "(è´›æˆ‘ä¸€å®šæ˜¯é è¨€å®¶)",
        "(æ•‘å‘½æˆ‘çš„å¡æˆæœƒè£œè¡€å•¦)", "(VV!!)", "(è¦ç ´ç”¢æƒ¹><)", "(ä»–çš„åå­—å¯èƒ½éœ€è¦æ’åˆ—çµ„åˆä¸€ä¸‹)"
    ];

    // æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹ç®¡ç†
    const state = {
        isGiftScene: true,
        isTransitioning: false,
        isModalOpen: false,
        isPermissionUnlocked: false,
        isGiftLocked: false,
        hasCakeBeenSeen: false,
        modal2Timer: null,

        isDragging: false,
        isClickValid: true,
        autoRotateSpeed: 0.003, // å¼§åº¦/å¹€ (å°‡æœƒè¢« deltaTime èª¿æ•´)
        targetRotationSpeed: 0.003,
        currentRotationSpeed: 0,

        dragHistory: [],
        previousMousePosition: { x: 0, y: 0 },
        initialPinchDistance: null,
        initialScale: 1,

        fireworkGlobalTime: 0,
        previousRotationY: 0,
        smoothedDeltaRotation: 0
    };

    let scene, camera, renderer, mainGroup, cakeGroup, giftGroup, raycaster, mouse;
    let clock; // æ–°å¢ Clock ç‰©ä»¶
    const flames = [];
    const fireworks = [];
    
    // Global references for gift animation
    let giftLidGroup, initialLidY; 

    const dom = {};

    function cacheDom() {
        dom.canvasContainer = document.getElementById("canvas-container");
        dom.transitionOverlay = document.getElementById("transition-overlay");
        dom.floatingText = document.getElementById("floating-text");
        dom.mainTitle = document.getElementById("main-title");
        dom.mainSubtitle = document.getElementById("main-subtitle");
        dom.btnReplay = document.getElementById("btn-replay");
        dom.body = document.body;
        // åŠ å…¥ BGM åƒè€ƒ
        dom.bgm = document.getElementById("bgm");
    }

    function init() {
        cacheDom();
        clock = new THREE.Clock(); // åˆå§‹åŒ–æ™‚é˜
        initThreeScene();
        createSceneObjects();
        initFireworksPool();
        window.addEventListener("resize", onWindowResize, false);
        animate();
    }
    
    function initThreeScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        camera = new THREE.PerspectiveCamera(
            50,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 12, 50);
        camera.lookAt(0, -2, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        dom.canvasContainer.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffebee, 0.6));

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 30, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const fillLight = new THREE.PointLight(0xffcdd2, 0.5);
        fillLight.position.set(-20, 10, -20);
        scene.add(fillLight);

        const candleLight = new THREE.PointLight(0xffaa00, 0.5, 30);
        candleLight.position.set(0, 15, 0);
        scene.add(candleLight);

        createStarfield();
    }

    function createSceneObjects() {
        mainGroup = new THREE.Group();
        mainGroup.position.y = -16;
        scene.add(mainGroup);

        createTable(mainGroup);

        giftGroup = new THREE.Group();
        createGiftBox(giftGroup); 
        mainGroup.add(giftGroup);

        cakeGroup = new THREE.Group();
        createCake(cakeGroup);
        cakeGroup.visible = false;
        mainGroup.add(cakeGroup);
    }
    
    function createTable(group) {
        const material = new THREE.MeshStandardMaterial({
            color: 0x5d4037,
            roughness: 0.8
        });

        const top = new THREE.Mesh(
            new THREE.CylinderGeometry(15, 15, 1, 64),
            material
        );
        top.position.y = -0.5;
        top.receiveShadow = true;
        group.add(top);

        const leg = new THREE.Mesh(
            new THREE.CylinderGeometry(1.5, 1.5, 50, 32),
            material
        );
        leg.position.y = -25.5;
        leg.receiveShadow = true;
        group.add(leg);
    }

    // å¯¦ä½œç¦®ç‰©ç›’ï¼šæ”¹æˆä¸­ç©ºæ¨£å¼ + å¤–éƒ¨è²¼ç‰‡ç·å¸¶
    function createGiftBox(group) {
        const size = 17;
        const height = size * 0.8;
        const wallThickness = 1.0; // ç‰†å£åšåº¦
        const boxMaterial = new THREE.MeshStandardMaterial({
            color: 0x81D8D0,
            roughness: 0.3,
            side: THREE.DoubleSide // ç¢ºä¿å…§å¤–éƒ½çœ‹å¾—åˆ°é¡è‰²
        });

        // --- å»ºç«‹ä¸­ç©ºç›’èº« (5å€‹é¢) ---
        // ç›’å­çš„åŸé»åº§æ¨™èª¿æ•´ï¼šåŸå…ˆå¯¦å¿ƒç›’å­ä¸­å¿ƒy = height/2ã€‚
        // æˆ‘å€‘è®“é€™å€‹æ–°çš„ç›’èº«ç¾¤çµ„çš„åº•éƒ¨å°é½Š y=0
        const boxBodyGroup = new THREE.Group();
        
        // 1. åº•éƒ¨
        const bottom = new THREE.Mesh(
            new THREE.BoxGeometry(size, wallThickness, size),
            boxMaterial
        );
        bottom.position.y = wallThickness / 2;
        bottom.receiveShadow = true;
        bottom.name = "giftBox";
        boxBodyGroup.add(bottom);

        // 2. å‰å¾Œå£ (æ²¿ Z è»¸)
        // å°ºå¯¸ï¼šå¯¬åº¦=size, é«˜åº¦=height, åšåº¦=wallThickness
        const frontWall = new THREE.Mesh(
            new THREE.BoxGeometry(size, height, wallThickness),
            boxMaterial
        );
        frontWall.position.set(0, height / 2, size / 2 - wallThickness / 2);
        frontWall.castShadow = true;
        frontWall.receiveShadow = true;
        frontWall.name = "giftBox";
        boxBodyGroup.add(frontWall);

        const backWall = frontWall.clone();
        backWall.position.set(0, height / 2, -(size / 2 - wallThickness / 2));
        backWall.name = "giftBox";
        boxBodyGroup.add(backWall);

        // 3. å·¦å³å£ (æ²¿ X è»¸)
        // å°ºå¯¸ï¼šå¯¬åº¦=wallThickness, é«˜åº¦=height, æ·±åº¦=size - 2*wallThickness (é¿å…é‡ç–Š)
        const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, height, size - 2 * wallThickness),
            boxMaterial
        );
        leftWall.position.set(-(size / 2 - wallThickness / 2), height / 2, 0);
        leftWall.castShadow = true;
        leftWall.receiveShadow = true;
        leftWall.name = "giftBox";
        boxBodyGroup.add(leftWall);

        const rightWall = leftWall.clone();
        rightWall.position.set((size / 2 - wallThickness / 2), height / 2, 0);
        rightWall.name = "giftBox";
        boxBodyGroup.add(rightWall);

        group.add(boxBodyGroup);
        // ---------------------------

        // ç¦®ç‰©ç›’è“‹ç¾¤çµ„ (Lid Group)
        giftLidGroup = new THREE.Group(); 
        group.add(giftLidGroup);
        
        const lidSize = size * 1.05;
        const lidHeight = 1.5;

        // è“‹å­æœ¬é«”
        const lid = new THREE.Mesh(
            new THREE.BoxGeometry(lidSize, lidHeight, lidSize),
            boxMaterial
        );
        lid.position.y = height + 0.75;
        lid.castShadow = true;
        lid.name = "giftBox"; 
        giftLidGroup.add(lid);

        // ç·å¸¶æè³ª
        const ribbonMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8
        });

        // --- ç›’èº«è²¼ç‰‡å¼ç·å¸¶ (åªè²¼åœ¨å¤–éƒ¨ï¼Œä¸è²«ç©¿å…§éƒ¨) ---
        const rWidth = 2.5;
        const rThick = 0.4; // ç¨å¾®çªå‡ºç‰†é¢
        
        // å‰æ–¹ç·å¸¶ (è²¼åœ¨å‰ç‰†å¤–å´)
        const ribFront = new THREE.Mesh(
            new THREE.BoxGeometry(rWidth, height, rThick),
            ribbonMaterial
        );
        ribFront.position.set(0, height / 2, size / 2 + rThick / 2);
        ribFront.castShadow = true;
        ribFront.receiveShadow = true;
        group.add(ribFront);

        // å¾Œæ–¹ç·å¸¶ (è²¼åœ¨å¾Œç‰†å¤–å´)
        const ribBack = ribFront.clone();
        ribBack.position.set(0, height / 2, -(size / 2 + rThick / 2));
        group.add(ribBack);

        // å·¦å´ç·å¸¶ (è²¼åœ¨å·¦ç‰†å¤–å´)
        const ribLeft = new THREE.Mesh(
            new THREE.BoxGeometry(rThick, height, rWidth),
            ribbonMaterial
        );
        ribLeft.position.set(-(size / 2 + rThick / 2), height / 2, 0);
        ribLeft.castShadow = true;
        ribLeft.receiveShadow = true;
        group.add(ribLeft);

        // å³å´ç·å¸¶ (è²¼åœ¨å³ç‰†å¤–å´)
        const ribRight = ribLeft.clone();
        ribRight.position.set((size / 2 + rThick / 2), height / 2, 0);
        group.add(ribRight);

        // åº•éƒ¨ç·å¸¶ (åå­—äº¤å‰)
        const ribBot1 = new THREE.Mesh(
            new THREE.BoxGeometry(rWidth, rThick, size + rThick),
            ribbonMaterial
        );
        ribBot1.position.set(0, -rThick/2, 0);
        group.add(ribBot1);

        const ribBot2 = new THREE.Mesh(
            new THREE.BoxGeometry(size + rThick, rThick, rWidth),
            ribbonMaterial
        );
        ribBot2.position.set(0, -rThick/2, 0);
        group.add(ribBot2);
        
        // --- è“‹å­è²¼ç‰‡å¼ç·å¸¶ (ä¿®æ”¹ç‚ºä¸è²«ç©¿è“‹å­åº•éƒ¨) ---
        const lidRibThick = 0.1; // è“‹å­ä¸Šçš„ç·å¸¶è–„ç‰‡åšåº¦

        // è“‹å­é ‚éƒ¨ç·å¸¶ (Xè»¸å‘)
        const lidRibTopX = new THREE.Mesh(
             new THREE.BoxGeometry(lidSize + lidRibThick, lidRibThick, rWidth),
             ribbonMaterial
        );
        lidRibTopX.position.set(0, lid.position.y + lidHeight/2 + lidRibThick/2, 0);
        giftLidGroup.add(lidRibTopX);

        // è“‹å­é ‚éƒ¨ç·å¸¶ (Zè»¸å‘)
        const lidRibTopZ = new THREE.Mesh(
             new THREE.BoxGeometry(rWidth, lidRibThick, lidSize + lidRibThick),
             ribbonMaterial
        );
        lidRibTopZ.position.set(0, lid.position.y + lidHeight/2 + lidRibThick/2, 0);
        giftLidGroup.add(lidRibTopZ);

        // è“‹å­å´é¢ç·å¸¶ - å‰
        const lidRibFront = new THREE.Mesh(
            new THREE.BoxGeometry(rWidth, lidHeight, lidRibThick),
            ribbonMaterial
        );
        lidRibFront.position.set(0, lid.position.y, lidSize/2 + lidRibThick/2);
        giftLidGroup.add(lidRibFront);

        // è“‹å­å´é¢ç·å¸¶ - å¾Œ
        const lidRibBack = lidRibFront.clone();
        lidRibBack.position.set(0, lid.position.y, -(lidSize/2 + lidRibThick/2));
        giftLidGroup.add(lidRibBack);

        // è“‹å­å´é¢ç·å¸¶ - å·¦
        const lidRibLeft = new THREE.Mesh(
            new THREE.BoxGeometry(lidRibThick, lidHeight, rWidth),
            ribbonMaterial
        );
        lidRibLeft.position.set(-(lidSize/2 + lidRibThick/2), lid.position.y, 0);
        giftLidGroup.add(lidRibLeft);

        // è“‹å­å´é¢ç·å¸¶ - å³
        const lidRibRight = lidRibLeft.clone();
        lidRibRight.position.set((lidSize/2 + lidRibThick/2), lid.position.y, 0);
        giftLidGroup.add(lidRibRight);
        
        // ------------------------------------------------

        // è´è¶çµç¾¤çµ„ (ä¿®æ­£ç‰ˆ4ï¼šæ­£ç¢ºçš„ç·å¸¶æ§‹æˆ - æ‰é¢æ§‹æˆåœ“ç’°)
        const bowGroup = new THREE.Group();
        // ä¿®æ”¹è™•ï¼šå°‡è´è¶çµæ•´é«”ä½ç½®å¾€ä¸ŠæŠ¬é«˜ (å¾ +0.5 æ”¹ç‚º +1.2)
        bowGroup.position.y = lid.position.y + 1.2; 
        
        // åƒæ•¸å®šç¾© (é¿å…èˆ‡å‰é¢çš„è®Šæ•¸åç¨±è¡çª)
        const bowRWidth = 2.5;  // ç·å¸¶å¯¬åº¦ (Renamed from rWidth)
        const bowRThick = 0.2;  // ç·å¸¶åšåº¦ (Renamed from rThick)
        const bowRadius = 1.8; // åœ“ç’°åŠå¾‘

        // é—œéµä¿®æ­£ï¼š
        // ä¹‹å‰çš„ tube æ˜¯å¯¬åº¦(éŒ¯èª¤)ï¼Œç¾åœ¨ tube æ˜¯åšåº¦çš„ä¸€åŠ(æ­£ç¢º)
        // æˆ‘å€‘å»ºç«‹ä¸€å€‹å¾ˆç´°çš„ç’°ï¼Œç„¶å¾Œåœ¨ Z è»¸æ‹‰é•·å®ƒè®Šæˆå¯¬å¸¶å­
        const bowGeo = new THREE.TorusGeometry(bowRadius, bowRThick / 2, 16, 64);
        
        // è¨ˆç®— Z è»¸æ‹‰ä¼¸æ¯”ä¾‹ï¼š ç›®æ¨™å¯¬åº¦ / åŸå§‹ç›´å¾‘
        const zScale = bowRWidth / bowRThick;

        // è¨­å®šè´è¶çµå¼µé–‹çš„è§’åº¦ (45åº¦)
        const bowAngle = Math.PI / 4; 

        // å·¦é‚Šçš„ç’°
        const leftBow = new THREE.Mesh(bowGeo, ribbonMaterial);
        // ç§»åˆ°å·¦å´ï¼Œä¸¦ç¨å¾®å¾€ä¸Šæ (Y: 1.2 -> 1.6)
        leftBow.position.set(-1.6, 1.6, 0); 
        
        // ç¸®æ”¾è¨­å®šï¼š
        // X: 1.2 (ç¨å¾®æ‹‰é•·)
        // Y: 0.6 (å£“æ‰æˆæ©¢åœ“)
        // Z: zScale (æ‹‰ä¼¸è®Šæˆå¯¬ç‰ˆç·å¸¶)
        leftBow.scale.set(1.2, 0.6, zScale); 
        
        // æ—‹è½‰è¨­å®šï¼š
        // Z: Math.PI - bowAngle (180 - 45 = 135åº¦) -> è®“æ©¢åœ“æŒ‡å‘å·¦ä¸Šæ–¹
        // Y: -Math.PI / 6 -> ç¨å¾®å‘å¾Œé–‹å±•
        leftBow.rotation.set(0, -Math.PI / 6, Math.PI - bowAngle);
        bowGroup.add(leftBow);

        // å³é‚Šçš„ç’°
        const rightBow = new THREE.Mesh(bowGeo, ribbonMaterial);
        // ç§»åˆ°å³å´ï¼Œä¸¦ç¨å¾®å¾€ä¸Šæ (Y: 1.2 -> 1.6)
        rightBow.position.set(1.6, 1.6, 0);
        rightBow.scale.set(1.2, 0.6, zScale);
        
        // æ—‹è½‰è¨­å®šï¼š
        // Z: bowAngle (45åº¦) -> è®“æ©¢åœ“æŒ‡å‘å³ä¸Šæ–¹
        // å°ç¨±æ—‹è½‰
        rightBow.rotation.set(0, Math.PI / 6, bowAngle);
        bowGroup.add(rightBow);

        // ä¸­å¿ƒçµ (æ¨¡æ“¬ç¶çµè™•)
        // ä½¿ç”¨åœ“æŸ±é«”ï¼Œé•·åº¦ç­‰æ–¼ç·å¸¶å¯¬
        const bowCenter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.7, 0.7, 2.6, 32),
            ribbonMaterial
        );
        // è½‰90åº¦è®“åœ“æŸ±æ©«èºº (Zè»¸)
        bowCenter.rotation.x = Math.PI / 2;
        bowCenter.rotation.z = Math.PI / 2;
        // ç¨å¾®å£“æ‰
        bowCenter.scale.set(1, 0.7, 1); 
        // ä¿®æ”¹è™•ï¼šä½ç½®å¾€ä¸‹ (Y: 0.6 -> 0.4)ï¼Œå†å¾€å‰çªå‡º (Z: 0.9 -> 1.2)
        bowCenter.position.set(0, 0.4, 1.2);
        bowGroup.add(bowCenter);
        
        giftLidGroup.add(bowGroup);

        initialLidY = giftLidGroup.position.y;
    }

    function createCake(group) {
        const baseY = 0;
        const pink = new THREE.MeshStandardMaterial({ color: 0xffb7c5, roughness: 0.6 });
        const cream = new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.8 });
        const stand = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });

        const plate = new THREE.Mesh(
            new THREE.CylinderGeometry(11, 11, 0.5, 64),
            stand
        );
        plate.position.y = baseY + 0.25;
        plate.receiveShadow = true;
        group.add(plate);

        const leg = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 3, 3, 32),
            stand
        );
        leg.position.y = baseY - 1.5;
        group.add(leg);

        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(5, 5, 0.4, 32),
            stand
        );
        base.position.y = baseY - 3;
        group.add(base);

        const bottomHeight = 5.4;
        const bottomRadius = 9;
        const topHeight = 3.6;
        const topRadius = 5.4;

        const bottomLayer = new THREE.Mesh(
            new THREE.CylinderGeometry(bottomRadius, bottomRadius, bottomHeight, 64),
            pink
        );
        bottomLayer.position.y = baseY + 0.5 + bottomHeight / 2;
        bottomLayer.castShadow = true;
        group.add(bottomLayer);

        addShellPiping(group, bottomRadius + 0.15, baseY + 0.7, 60, cream); 
        addWaveLace(group, bottomRadius, baseY + 0.5 + bottomHeight * 0.6, 20, cream); 
        addCloudPiping(group, bottomRadius, baseY + 0.5 + bottomHeight, 40, cream); 
        decorateShelf(group, bottomRadius / 2 + topRadius / 2 + 0.5, baseY + 0.5 + bottomHeight);

        const topLayer = new THREE.Mesh(
            new THREE.CylinderGeometry(topRadius, topRadius, topHeight, 64),
            pink
        );
        topLayer.position.y = baseY + 0.5 + bottomHeight + topHeight / 2;
        topLayer.castShadow = true;
        group.add(topLayer);

        const topY = baseY + 0.5 + bottomHeight + topHeight;

        addFluffyPiping(group, topRadius - 0.2, topY, 24, cream); 
        decorateTopEdge(group, topRadius - 0.8, topY); 
        createCandles(group, topRadius - 1.8, topY); 
    }

    function addShellPiping(group, radius, y, count, material) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.45, 16, 16, 0, Math.PI),
                material
            );
            mesh.position.set(
                Math.cos(angle) * radius,
                y - 0.2,
                Math.sin(angle) * radius
            );
            mesh.rotation.x = -Math.PI / 2;
            mesh.rotation.z = angle + Math.PI / 2;
            mesh.scale.set(1.1, 0.7, 1.3);
            group.add(mesh);
        }
    }

    function addWaveLace(group, radius, y, cycles, material) {
        const points = [];
        const segments = 250;
        const amplitude = 0.7;

        for (let i = 0; i <= segments; i++) {
            const t = (i / segments) * Math.PI * 2;
            const angle = t;
            const height = y + Math.sin(angle * cycles) * amplitude;
            points.push(
                new THREE.Vector3(
                    Math.cos(angle) * (radius + 0.08),
                    height,
                    Math.sin(angle) * (radius + 0.08)
                )
            );
        }

        const curve = new THREE.CatmullRomCurve3(points);
        curve.closed = true;

        const tube = new THREE.Mesh(
            new THREE.TubeGeometry(curve, segments, 0.18, 8, true),
            material
        );
        group.add(tube);

        const pinkMaterial = new THREE.MeshBasicMaterial({ color: 0xff80ab });
        const thinTube = new THREE.Mesh(
            new THREE.TubeGeometry(curve, segments, 0.04, 8, true),
            pinkMaterial
        );
        thinTube.scale.set(1.01, 1, 1.01);
        group.add(thinTube);

        for (let i = 0; i < cycles; i++) {
            const angle = ((i + 0.75) / cycles) * Math.PI * 2;
            createFlower(
                group,
                Math.cos(angle) * (radius + 0.15),
                y - amplitude,
                Math.sin(angle) * (radius + 0.15)
            );
        }
    }

    function createFlower(group, x, y, z) {
        const flowerGroup = new THREE.Group();
        flowerGroup.position.set(x, y, z);
        flowerGroup.lookAt(0, y, 0);

        const petal = new THREE.Mesh(
            new THREE.CircleGeometry(0.2, 5),
            new THREE.MeshStandardMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide
            })
        );
        flowerGroup.add(petal);

        const center = new THREE.Mesh(
            new THREE.CircleGeometry(0.07, 8),
            new THREE.MeshBasicMaterial({ color: 0xffeb3b })
        );
        center.position.z = 0.015;
        flowerGroup.add(center);

        group.add(flowerGroup);
    }

    function addCloudPiping(group, radius, y, count, material) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                material
            );
            mesh.position.set(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );
            mesh.scale.set(1.2, 0.8, 1);
            group.add(mesh);
        }
    }

    function addFluffyPiping(group, radius, y, count, material) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const mesh = new THREE.Mesh(
                new THREE.IcosahedronGeometry(0.55, 1),
                material
            );
            mesh.position.set(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );
            mesh.scale.set(1, 0.8, 1);
            mesh.rotation.y = Math.random() * Math.PI;
            group.add(mesh);
        }
    }

    function decorateShelf(group, radius, y) {
        for (let i = 0; i < 15; i++) {
            const angle = (i / 15) * Math.PI * 2;
            const strawberry = createStrawberry();
            strawberry.position.set(
                Math.cos(angle) * radius,
                y + 0.4,
                Math.sin(angle) * radius
            );
            strawberry.rotation.y = -angle;
            strawberry.rotateX(Math.PI / 12);
            group.add(strawberry);
        }
    }

    function decorateTopEdge(group, radius, y) {
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            if (i % 2 === 0) {
                const macaron = createMacaron();
                macaron.position.set(x, y + 0.3, z);
                macaron.lookAt(0, y, 0);
                macaron.rotateX(Math.PI / 6);
                group.add(macaron);
            } else {
                const strawberry = createStrawberry();
                strawberry.position.set(x, y + 0.4, z);
                strawberry.rotation.y = -angle;
                strawberry.rotateX(Math.PI / 12);
                group.add(strawberry);
            }
        }
    }

    function createCandles(group, radius, y) {
        const createRing = (rad, count) => {
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;

                const candle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 1.2, 12),
                    new THREE.MeshStandardMaterial({
                        color: 0xffd700,
                        metalness: 0.6,
                        roughness: 0.2
                    })
                );
                candle.position.set(
                    Math.cos(angle) * rad,
                    y + 0.6,
                    Math.sin(angle) * rad
                );
                candle.castShadow = true;
                group.add(candle);

                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.3, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffaa00 })
                );
                flame.position.set(0, 0.75, 0);
                candle.add(flame);

                flames.push({
                    mesh: flame,
                    base: 1,
                    spd: 0.15,
                    off: Math.random() * 10
                });
            }
        };

        createRing(radius * 0.6, 8); 
        createRing(radius, 12); 
    }

    function createStrawberry() {
        const group = new THREE.Group();
        const points = [];

        for (let i = 0; i < 10; i++) {
            points.push(new THREE.Vector2(Math.sin(i * 0.25) * 0.3, (i - 5) * 0.08));
        }
        points.push(new THREE.Vector2(0, 0.4));

        const body = new THREE.Mesh(
            new THREE.LatheGeometry(points, 16),
            new THREE.MeshStandardMaterial({ color: 0xe91e63, roughness: 0.3 })
        );
        group.add(body);

        const leafMaterial = new THREE.MeshStandardMaterial({
            color: 0x228b22,
            roughness: 1,
            emissive: 0x114411,
            emissiveIntensity: 0.3,
            side: THREE.DoubleSide
        });

        const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.2, 8),
            leafMaterial
        );
        stem.position.y = 0.45;
        group.add(stem);

        const leafGroup = new THREE.Group();
        leafGroup.position.y = 0.42;

        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.quadraticCurveTo(0.12, 0.08, 0, 0.25);
        shape.quadraticCurveTo(-0.12, 0.08, 0, 0);

        for (let i = 0; i < 5; i++) {
            const geometry = new THREE.ShapeGeometry(shape, 5);
            const pos = geometry.attributes.position;
            for (let k = 0; k < pos.count; k++) {
                pos.setZ(k, pos.getZ(k) + pos.getY(k) * pos.getY(k) * 1.5);
            }
            geometry.computeVertexNormals();

            const leaf = new THREE.Mesh(geometry, leafMaterial);
            const wrapper = new THREE.Group();
            wrapper.rotation.y = (i / 5) * Math.PI * 2;
            leaf.rotation.x = -Math.PI / 1.7;
            wrapper.add(leaf);
            leafGroup.add(wrapper);
        }

        group.add(leafGroup);
        group.scale.set(1.5, 1.5, 1.5);

        return group;
    }

    function createMacaron() {
        const group = new THREE.Group();
        const shellMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8bbd0, 
            roughness: 0.5
        });

        const shellGeometry = new THREE.SphereGeometry(
            0.4, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2.5
        );

        const top = new THREE.Mesh(shellGeometry, shellMaterial);
        top.position.y = -0.06;
        group.add(top);

        const bottom = new THREE.Mesh(shellGeometry, shellMaterial);
        bottom.rotation.x = Math.PI;
        bottom.position.y = 0.06;
        group.add(bottom);

        const fillingMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8bbd0,
            roughness: 1
        });

        const fillingGeometry = new THREE.TorusGeometry(0.38, 0.04, 12, 32);

        const topFilling = new THREE.Mesh(fillingGeometry, fillingMaterial);
        topFilling.rotation.x = Math.PI / 2;
        topFilling.position.y = 0.05;
        group.add(topFilling);

        const bottomFilling = new THREE.Mesh(fillingGeometry, fillingMaterial);
        bottomFilling.rotation.x = Math.PI / 2;
        bottomFilling.position.y = -0.05;
        group.add(bottomFilling);

        const cream = new THREE.Mesh(
            new THREE.CylinderGeometry(0.36, 0.36, 0.12, 32),
            new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        group.add(cream);

        group.scale.set(1.2, 1.2, 1.2);
        return group;
    }

    function createStarfield() {
        const gSmall = new THREE.BufferGeometry();
        const gMedium = new THREE.BufferGeometry();
        const gLarge = new THREE.BufferGeometry();
        const small = [];
        const medium = [];
        const large = [];
        
        const safeRadiusSq = 20 * 20; 
        const totalStars = 2500;

        for (let i = 0; i < totalStars; i++) {
            let x, y, z;
            let r;
            
            do {
                x = (Math.random() - 0.5) * 500;
                y = (Math.random() - 0.5) * 500;
                z = (Math.random() - 0.5) * 500;
            } while (x*x + y*y + z*z < safeRadiusSq);

            r = Math.random();

            if (r > 0.9) {
                large.push(x, y, z);
            } else if (r > 0.7) {
                medium.push(x, y, z);
            } else {
                small.push(x, y, z);
            }
        }

        if (small.length) {
            gSmall.setAttribute(
                "position",
                new THREE.BufferAttribute(new Float32Array(small), 3)
            );
            scene.add(
                new THREE.Points(
                    gSmall,
                    new THREE.PointsMaterial({
                        size: 2,
                        sizeAttenuation: false,
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    })
                )
            );
        }

        if (medium.length) {
            gMedium.setAttribute(
                "position",
                new THREE.BufferAttribute(new Float32Array(medium), 3)
            );
            scene.add(
                new THREE.Points(
                    gMedium,
                    new THREE.PointsMaterial({
                        size: 2.4,
                        sizeAttenuation: false,
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.85
                    })
                )
            );
        }

        if (large.length) {
            gLarge.setAttribute(
                "position",
                new THREE.BufferAttribute(new Float32Array(large), 3)
            );
            scene.add(
                new THREE.Points(
                    gLarge,
                    new THREE.PointsMaterial({
                        size: 2.8,
                        sizeAttenuation: false,
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.9
                    })
                )
            );
        }
    }

    class Firework {
        constructor(offset) {
            this.offset = offset;
            this.launchDuration = 30; // å¾ 60 æ¸›å°‘åˆ° 30 (å‡ç©ºæ¥µå¿«)
            this.explosionDuration = 240; // ä¿æŒä¸è®Š
            this.totalDuration = 270; // æ›´æ–°ç¸½æ™‚é–“ (30 + 240)

            this.startPos = new THREE.Vector3(
                (Math.random() - 0.5) * 100,
                -30,
                (Math.random() - 0.5) * 80 - 40
            );
            this.targetPos = new THREE.Vector3(
                this.startPos.x,
                8 + Math.random() * 15,
                this.startPos.z
            );
            this.color = new THREE.Color().setHSL(Math.random(), 1, 0.6);

            this.lightMesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 8, 8),
                new THREE.MeshBasicMaterial({ color: this.color })
            );
            scene.add(this.lightMesh);

            this.particleGroup = new THREE.Group();
            this.particlesData = [];

            const particleGeometry = new THREE.SphereGeometry(0.25, 6, 6);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: this.color,
                transparent: true
            });

            for (let i = 0; i < 80; i++) {
                const particle = new THREE.Mesh(
                    particleGeometry,
                    particleMaterial.clone()
                );
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.4 + Math.random() * 0.6;

                this.particleGroup.add(particle);
                this.particlesData.push({
                    mesh: particle,
                    velocity: new THREE.Vector3(
                        speed * Math.sin(phi) * Math.cos(theta),
                        speed * Math.sin(phi) * Math.sin(theta),
                        speed * Math.cos(phi)
                    )
                });
            }

            this.particleGroup.visible = false;
            this.lightMesh.visible = false;
            scene.add(this.particleGroup);
        }

        update(globalTime) {
            let t = (globalTime + this.offset) % FIREWORK_CYCLE_DURATION;
            if (t < 0) t += FIREWORK_CYCLE_DURATION;

            if (t <= this.launchDuration) {
                this.lightMesh.visible = true;
                this.particleGroup.visible = false;
                const ratio = 1 - Math.pow(1 - t / this.launchDuration, 2); 
                this.lightMesh.position.lerpVectors(
                    this.startPos,
                    this.targetPos,
                    ratio
                );
            } else if (t <= this.totalDuration) {
                this.lightMesh.visible = false;
                this.particleGroup.visible = true;
                this.particleGroup.position.copy(this.targetPos);

                const elapsed = t - this.launchDuration;
                const progress = elapsed / this.explosionDuration;

                this.particlesData.forEach((p) => {
                    p.mesh.position.copy(p.velocity).multiplyScalar(elapsed);
                    p.mesh.position.y -= 0.005 * elapsed * elapsed; 
                    p.mesh.scale.setScalar(1 - progress * 0.5);
                    p.mesh.material.opacity = 1 - progress;
                });
            } else {
                this.lightMesh.visible = false;
                this.particleGroup.visible = false;
            }
        }
        
        stop() {
            // é€éå°‡åç§»æ™‚é–“è¨­ç½®ç‚ºä¸€å€‹æœƒå°è‡´ 't' å§‹çµ‚è™•æ–¼é–’ç½®éšæ®µçš„å€¼ä¾†éš±è—ç²’å­
            this.offset = -FIREWORK_CYCLE_DURATION * 2; 
            this.lightMesh.visible = false;
            this.particleGroup.visible = false;
        }
    }

    function initFireworksPool() {
        for (let i = 0; i < FIREWORK_POOL_SIZE; i++) {
             // ä¿®æ­£é» 1. åˆå§‹éš¨æ©Ÿåç§»ï¼Œé˜²æ­¢åŒæ­¥æ’­æ”¾
            fireworks.push(
                new Firework(
                    Math.random() * FIREWORK_CYCLE_DURATION
                )
            );
        }
    }


    // é¡¯ç¤ºçŸ­æš«çš„æµ®å‹•æ–‡å­—æç¤º
    function showFloatingText(text, color) {
        const el = dom.floatingText;
        el.innerText = text;
        el.style.color = color;
        el.classList.add("show");
        
        setTimeout(() => {
            el.classList.remove("show");
        }, FLOATING_TEXT_DURATION);
    }

    // é¡¯ç¤ºæ¨¡æ…‹å½ˆçª—
    function showModal(id) {
        closeAllModals();
        const modal = document.getElementById(id);
        if (modal) {
            modal.classList.add("active");
            state.isModalOpen = true;
        }
    }

    // é—œé–‰æ‰€æœ‰æ¨¡æ…‹å½ˆçª—
    function closeAllModals() {
        document
            .querySelectorAll(".modal-overlay")
            .forEach((m) => m.classList.remove("active"));
        state.isModalOpen = false;
    }

    // è§¸ç™¼æ¬Šé™æª¢æŸ¥å’Œç¬¬ä¸€å€‹æ¨¡æ…‹çª—
    function triggerPermissionSequence() {
        // ä¿®æ­£é» 1: åœ¨é€™è£¡ç«‹å³éš±è—å‰¯æ¨™é¡Œ
        dom.mainSubtitle.style.opacity = 0;
        
        showFloatingText("æ‚¨å°šæœªæ“æœ‰è§£é–ç¦®ç‰©çš„æ¬Šé™ï¼", "#ff3333");
        setTimeout(() => showModal("modal-1"), FLOATING_TEXT_DURATION);
    }

    // ç¦®ç‰©è§£é–éå ´å‹•ç•«èˆ‡å ´æ™¯åˆ‡æ›
    function openGift() {
        if (state.isTransitioning) return;
        
        // === é—œéµä¿®æ”¹ï¼šiOS éŸ³è¨Šè§£é– (Audio Unlock) ===
        // åœ¨ä½¿ç”¨è€…è§¸ç™¼é»æ“Šçš„ç•¶ä¸‹ï¼Œç«‹åˆ»æ’­æ”¾ä¸¦æš«åœï¼Œå–å¾—æ’­æ”¾æ¬Šé™
        if (dom.bgm) {
            dom.bgm.volume = 0; // å…ˆéœéŸ³ï¼Œé¿å…è½åˆ°é›œéŸ³
            dom.bgm.play().then(() => {
                dom.bgm.pause();
                dom.bgm.currentTime = 0;
                dom.bgm.volume = 1; // æ¢å¾©éŸ³é‡ï¼Œæº–å‚™çœŸæ­£æ’­æ”¾
            }).catch((e) => {
                console.log("iOS éŸ³è¨Šæ¬Šé™ç²å–å¤±æ•—ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨è€…å†æ¬¡äº’å‹•", e);
            });
        }
        // ==========================================
        
        state.isTransitioning = true;
        dom.body.style.pointerEvents = 'none'; // ç¦ç”¨é»æ“Š

        // è¨­ç½®é€²å…¥è›‹ç³•è½‰å ´çš„é¡è‰²ç‚ºæ·ºç°è‰²
        dom.transitionOverlay.style.backgroundColor = '#e6e6e6'; 
        dom.transitionOverlay.style.opacity = 1; 

        // --- æ–°å¢: ç¦®ç‰©è“‹å‘ä¸Šé–‹å•Ÿçš„å‹•ç•« ---
        const liftDuration = 1200; 
        const liftHeight = 30;
        let startTime = Date.now();

        function animateLid() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / liftDuration);
            
            if (giftLidGroup) {
                // ä½¿ç”¨ group çš„ position ä¾†æ§åˆ¶æ•´å€‹è“‹å­ + ç·å¸¶ + è´è¶çµ
                const yOffset = liftHeight * progress; 
                giftLidGroup.position.y = yOffset;
            }

            if (progress < 1) {
                requestAnimationFrame(animateLid);
            } else {
                 if (giftLidGroup) {
                    giftLidGroup.position.y = liftHeight;
                }
            }
        }
        requestAnimationFrame(animateLid);
        // ------------------------------------

        setTimeout(() => { // Executes at 1.2s (when opaque)
            // --- Scene Switch Logic ---
            state.isGiftScene = false;
            giftGroup.visible = false;
            cakeGroup.visible = true;

            // é‡ç½®è“‹å­çµ„çš„ä½ç½®ï¼Œä»¥ä¾¿ä¸‹æ¬¡é‡å•Ÿæ™‚ä½¿ç”¨
            if (giftLidGroup) {
                giftLidGroup.position.y = 0;
            }
            
            dom.mainTitle.innerText = "é˜¿å¦ƒç”Ÿæ—¥å¿«æ¨‚ï¼";
            dom.mainTitle.classList.add("neon-active");

            // è™•ç†å‰¯æ¨™é¡Œ
            let subtitleText = SUBTITLES[0]; 
            if (state.hasCakeBeenSeen) {
                let randomSubtitles = SUBTITLES.slice(1);
                if (randomSubtitles.length > 0) {
                    subtitleText = randomSubtitles[Math.floor(Math.random() * randomSubtitles.length)];
                } 
            }
            state.hasCakeBeenSeen = true;

            dom.mainSubtitle.innerText = subtitleText;
            dom.mainSubtitle.style.opacity = 1;

            dom.btnReplay.style.display = 'flex';

            state.currentRotationSpeed = state.autoRotateSpeed;

            // é€™è£¡æ˜¯ç™½å¹•æŒçºŒçš„æ™‚é–“ï¼Œç›®å‰è¨­å®š 1200ms (1.2ç§’) å¾Œé–‹å§‹æ·¡å‡º
            setTimeout(() => { 
                // === ä¿®æ”¹è™•ï¼šéŸ³æ¨‚ç§»åˆ°é€™è£¡æ’­æ”¾ (è›‹ç³•æ­æ›‰çš„ç¬é–“) ===
                if (dom.bgm) {
                    // å˜—è©¦æ’­æ”¾éŸ³æ¨‚
                    dom.bgm.currentTime = 0;
                    dom.bgm.play().catch(e => console.log("æ’­æ”¾å¤±æ•—ï¼Œå¯èƒ½æ˜¯ç€è¦½å™¨é™åˆ¶:", e));
                }
                // ===========================================

                dom.transitionOverlay.style.opacity = 0; // é–‹å§‹è®Šé€æ˜
                
                // ç­‰å¾…é€æ˜åº¦å‹•ç•«å®Œæˆå¾Œ (CSS transition 1.2s)ï¼Œæ‰æ¢å¾©é»æ“Š
                setTimeout(() => {
                    state.isTransitioning = false;
                    dom.body.style.pointerEvents = 'auto'; 
                }, 1200); 
                
            }, 1200); // é€™è£¡çš„æ•¸å€¼æ§åˆ¶ã€Œç™½å¹•åœç•™å¤šä¹…ã€ï¼Œæ‚¨å¯ä»¥æ”¹æˆ 2000 è®“å®ƒåœæ›´ä¹…
        }, 1200); // Wait for transition in duration
    }

    // æ¨¡æ…‹çª— 2 é‚è¼¯ (å¸¶æœ‰è¨ˆæ™‚å™¨çš„å½©è›‹)
    function showModal2() {
        closeAllModals();
        showFloatingText("0.0ï¼", "#fff");
        // å»¶é²åŒæ­¥åˆ°æµ®å‹•æ–‡å­—æŒçºŒæ™‚é–“
        state.modal2Timer = setTimeout(() => {
            showModal("modal-2");
            state.modal2Timer = null;
        }, FLOATING_TEXT_DURATION);
    }
    
    // è¨­ç½®ç¦®ç‰©é–å®šç‹€æ…‹
    function showModal3AndLockGift() {
        closeAllModals();
        state.isGiftLocked = true; // è¨­ç½®é–å®šç‹€æ…‹
        showModal("modal-3");
    }

    // ä¿®å¾©å½ˆçª—çš„å‹•ç•«é‚è¼¯ (ä¿®æ­£ 1)
    function showRepairModal() {
        showModal("modal-repair");

        const text = document.getElementById("repair-text");
        const subtext = document.getElementById("repair-subtext");
        const btn = document.getElementById("btn-repair-complete");

        const sequence = ["ä¿®å¾©ä¸­.", "ä¿®å¾©ä¸­..", "ä¿®å¾©ä¸­..."];
        let count = 0;
        let index = 0;
        const totalCycles = 3; // ç¢ºä¿å¾ªç’°æ¬¡æ•¸

        btn.style.display = "none";
        subtext.style.display = "none";
        text.innerText = sequence[0]; // ç¢ºä¿åˆå§‹é¡¯ç¤ºç‚ºç¬¬ä¸€å€‹

        const interval = setInterval(() => {
            // æ¯æ¬¡è¨ˆæ™‚å™¨è§¸ç™¼ï¼Œå¢åŠ  indexï¼Œä¸¦æª¢æŸ¥æ˜¯å¦å®Œæˆä¸€å€‹å®Œæ•´çš„å¾ªç’° (3å€‹é»)
            index = (index + 1) % sequence.length;
            text.innerText = sequence[index];

            // åªæœ‰ç•¶ index å›åˆ° 0 æ™‚ï¼Œæ‰å¢åŠ  count
            if (index === 0) {
                count++;
            }

            // æª¢æŸ¥æ˜¯å¦é”åˆ°ç¸½å¾ªç’°æ¬¡æ•¸
            if (count >= totalCycles) {
                clearInterval(interval);
                text.innerText = "ä¿®å¾©å®Œæˆï¼";
                subtext.style.display = "block";
                btn.style.display = "inline-block";
            }
        }, 700);
    }

    // ç¢ºèªæ”¯ä»˜/è§£é–ï¼Œä¸¦è§£é™¤é–å®š
    function confirmPayment() {
        closeAllModals();
        state.isPermissionUnlocked = true; // ç¢ºä¿æ¬Šé™è¢«è¨­å®š
        state.isGiftLocked = false; // è§£é™¤é–å®š
        setTimeout(openGift, 200);
    }

    // ç›´æ¥è§£é–æ¬Šé™ï¼Œä¸¦è§£é™¤é–å®š
    function unlockPermissionSequence() {
        closeAllModals();
        showFloatingText("å·²æˆåŠŸè§£é–æ¬Šé™ï¼", "#33ff33");
        state.isPermissionUnlocked = true;
        state.isGiftLocked = false; // è§£é™¤é–å®š
    }
    
    // 2. è»Ÿé‡å•ŸéŠæˆ²åŠŸèƒ½ (Soft Reset)
    function restartGameSoft() {
        if (state.isTransitioning) return;
        
        state.isTransitioning = true;
        dom.body.style.pointerEvents = 'none'; // ç¦ç”¨é»æ“Š

        // è¨­ç½®é‡å•Ÿè½‰å ´çš„é¡è‰²ç‚ºé»‘è‰²
        dom.transitionOverlay.style.backgroundColor = '#050510'; 
        dom.transitionOverlay.style.opacity = 1;

        // é‡å•Ÿè½‰å ´æç¤º
        showFloatingText("é‡å•Ÿä¸­...", "#fff"); 

        // === åœæ­¢ä¸¦é‡ç½®éŸ³æ¨‚ ===
        if (dom.bgm) {
            dom.bgm.pause();
            dom.bgm.currentTime = 0;
        }
        // ====================

        // åœæ­¢ç…™ç«ä¸¦é‡æ–°éš¨æ©Ÿåˆ†é…åç§» (ä¿®æ­£é» 1)
        fireworks.forEach(fw => {
            fw.stop();
            fw.offset = Math.random() * FIREWORK_CYCLE_DURATION;
        });

        // é‡è¨­æ‰€æœ‰ç‹€æ…‹
        state.isGiftScene = true;
        state.isPermissionUnlocked = false;
        state.isGiftLocked = false;
        state.modal2Timer = null;
        // state.hasCakeBeenSeen ä¿æŒå…¶å€¼ (true æˆ– false)ï¼Œä»¥ç¢ºä¿ä¸‹æ¬¡é»æ“Šæ™‚é€²å…¥éš¨æ©Ÿå‰¯æ¨™é¡Œé‚è¼¯
        state.currentRotationSpeed = 0;
        state.targetRotationSpeed = 0.003;
        mainGroup.scale.set(1, 1, 1);
        mainGroup.rotation.y = 0;
        
        dom.btnReplay.style.display = 'none';

        setTimeout(() => {
            // åˆ‡æ›å ´æ™¯ç‰©ä»¶çš„å¯è¦‹æ€§ (åœ¨è½‰å ´å¿«çµæŸæ™‚)
            giftGroup.visible = true;
            cakeGroup.visible = false;
            
            // é‡ç½®è“‹å­ä½ç½® (ç¢ºä¿å®ƒå›åˆ°äº† Group çš„åŸé»)
            if (giftLidGroup) {
                giftLidGroup.position.y = 0;
            }

            // é‡ç½®æ¨™é¡Œ
            dom.mainTitle.innerText = "ç¦®ç‰©?";
            dom.mainTitle.classList.remove("neon-active");
            
            // é‡ç½®å‰¯æ¨™é¡Œç‚ºæç¤ºæ–‡å­—
            dom.mainSubtitle.innerText = "é»æ“Šç¦®ç‰©ç›’...?";
            dom.mainSubtitle.style.opacity = 1;

            // è½‰å ´çµæŸ
            setTimeout(() => {
                dom.transitionOverlay.style.opacity = 0;
                state.isTransitioning = false;
                dom.body.style.pointerEvents = 'auto'; // æ¢å¾©é»æ“Š
            }, 1200);
        }, 1200);
    }


    // å°‡æ‰€æœ‰æ¨¡æ…‹çª—è™•ç†å‡½å¼æ›è¼‰åˆ° windowï¼Œä»¥ä¾¿ HTML å…§è¯ onclick å‘¼å«
    window.showModal2 = showModal2;
    window.showModal3 = showModal3AndLockGift;
    window.showModal4 = () => showModal("modal-4");
    window.showModal5 = () => showModal("modal-5");
    window.showModal6 = () => showModal("modal-6");
    window.showModal7 = () => showModal("modal-7");
    window.showModal8 = () => showModal("modal-8");
    window.showModal9 = () => showModal("modal-9");
    window.showModal10 = () => showModal("modal-10");
    window.showModal11 = () => showModal("modal-11");
    window.showModal12 = () => showModal("modal-12");

    window.showModal404 = () => showModal("modal-404");
    window.showModalY = () => showModal("modal-y");
    window.showModalZ = () => showModal("modal-z");
    window.showModalA = () => showModal("modal-a");
    window.showModalB = () => showModal("modal-b");
    window.showModalC = () => showModal("modal-c");
    window.showModalX = () => showModal("modal-x"); 

    window.showRepairModal = showRepairModal; 
    window.confirmPayment = confirmPayment;
    window.unlockPermissionSequence = unlockPermissionSequence;
    window.restartGameSoft = restartGameSoft; // åŒ¯å‡ºè»Ÿé‡å•ŸåŠŸèƒ½ (ç”¨æ–¼æŒ‰éˆ•é»æ“Š)

    // è¨­ç½®æ»‘é¼ å’Œè§¸æ§äº’å‹•
    function setupInteraction() {
        const container = dom.canvasContainer;

        const start = (x, y) => {
            if (state.isModalOpen || state.isTransitioning) return; // æª¢æŸ¥é–å®šç‹€æ…‹
            state.isDragging = true;
            state.isClickValid = true;
            state.previousMousePosition = { x, y };
            state.dragHistory = [
                {
                    t: Date.now(),
                    y: mainGroup ? mainGroup.rotation.y : 0
                }
            ];
            if (!state.isGiftScene) state.currentRotationSpeed = 0;
        };

        const move = (x, y) => {
            if (!state.isDragging) return;

            if (Math.abs(x - state.previousMousePosition.x) > 2 || Math.abs(y - state.previousMousePosition.y) > 2) {
                state.isClickValid = false;
            }

            if (mainGroup) {
                const dx = x - state.previousMousePosition.x;
                if (!state.isGiftScene) {
                    mainGroup.rotation.y += dx * 0.005;
                }
                
                const now = Date.now();
                state.dragHistory.push({
                    t: now,
                    y: mainGroup.rotation.y
                });
                state.dragHistory = state.dragHistory.filter(
                    (d) => now - d.t < 150
                );
            }

            state.previousMousePosition = { x, y };
        };

        const end = (clientX, clientY) => {
            if (!state.isDragging) return;
            state.isDragging = false;
            
            // åœ¨é»æ“Šè™•ç†ä¸­ä¹Ÿæª¢æŸ¥é–å®šç‹€æ…‹ (åŒ…æ‹¬æµ®å‹•æç¤º)
            if (state.isClickValid && !state.isModalOpen && !state.isTransitioning) { 
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                if (state.isGiftScene) {
                    const hits = raycaster.intersectObjects(
                        giftGroup.children,
                        true
                    );
                    const hitGift = hits.some(
                        (h) => h.object.name === "giftBox"
                    );

                    if (hitGift) {
                        // æª¢æŸ¥ 404 å½©è›‹è§¸ç™¼æ¢ä»¶ (ä¿®æ­£é» 1)
                        if (state.modal2Timer) {
                            clearTimeout(state.modal2Timer);
                            state.modal2Timer = null;
                            showModal("modal-404");
                            return; // é˜»æ­¢åŸ·è¡Œå¾ŒçºŒé‚è¼¯
                        }
                        
                        if (state.isGiftLocked && !state.isPermissionUnlocked) {
                            showFloatingText("ç¦®ç‰©å·²ä¸Šé–ï¼Œè«‹å®Œæˆäº¤æ˜“æˆ–å˜—è©¦å…¶ä»–æ–¹æ³•ã€‚", "#ff3333");
                            return;
                        }

                        if (state.isPermissionUnlocked) {
                            openGift();
                        } else {
                            triggerPermissionSequence();
                        }
                    }
                }
            }

            if (!state.isGiftScene) {
                const now = Date.now();
                const first = state.dragHistory[0];

                if (first && now - first.t > 0) {
                    const velocity =
                        (mainGroup.rotation.y - first.y) / (now - first.t);
                    state.currentRotationSpeed = velocity * 16; 
                } else {
                    state.currentRotationSpeed = 0;
                }

                state.targetRotationSpeed = state.autoRotateSpeed; 
            }
        };

        container.addEventListener(
            "wheel",
            (e) => {
                if (!state.isModalOpen && mainGroup) {
                    e.preventDefault();
                    let scale =
                        mainGroup.scale.x * (1 + e.deltaY * -0.001);
                    scale = Math.max(1, Math.min(3, scale)); 
                    mainGroup.scale.set(scale, scale, scale);
                    state.initialScale = scale;
                }
            },
            { passive: false }
        );

        container.addEventListener("mousedown", (e) =>
            start(e.clientX, e.clientY)
        );
        window.addEventListener("mousemove", (e) =>
            move(e.clientX, e.clientY)
        );
        window.addEventListener("mouseup", (e) =>
            end(e.clientX, e.clientY)
        );

        container.addEventListener(
            "touchstart",
            (e) => {
                if (state.isModalOpen || state.isTransitioning) return; // æª¢æŸ¥é–å®šç‹€æ…‹
                if (e.touches.length === 1) {
                    start(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    state.initialPinchDistance = getPinchDistance(
                        e.touches[0],
                        e.touches[1]
                    );
                    if (mainGroup) state.initialScale = mainGroup.scale.x;
                }
            },
            { passive: false }
        );

        container.addEventListener(
            "touchmove",
            (e) => {
                if (state.isModalOpen || state.isTransitioning) return;
                if (e.touches.length === 1) {
                    move(e.touches[0].clientX, e.touches[0].clientY);
                } else if (
                    e.touches.length === 2 &&
                    state.initialPinchDistance
                ) {
                    const current = getPinchDistance(
                        e.touches[0],
                        e.touches[1]
                    );
                    let scale =
                        state.initialScale *
                        (current / state.initialPinchDistance);
                    scale = Math.max(1, Math.min(3, scale));
                    if (mainGroup) mainGroup.scale.set(scale, scale, scale);
                }
            },
            { passive: false }
        );

        container.addEventListener(
            "touchend",
            (e) => {
                if (e.touches.length === 0) {
                    end(
                        state.previousMousePosition.x,
                        state.previousMousePosition.y
                    );
                } else if (e.touches.length < 2) {
                    state.initialPinchDistance = null;
                }
            },
            { passive: false }
        );
    }

    // è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢ (ç”¨æ–¼æåˆç¸®æ”¾)
    function getPinchDistance(t1, t2) {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // ä¸»æ¸²æŸ“å¾ªç’°
    function animate() {
        requestAnimationFrame(animate);

        // ä½¿ç”¨ Clock è¨ˆç®— Delta Time (ç§’)
        const dt = clock.getDelta();
        // æˆ‘å€‘å°‡åŸºæº–è¨­ç‚º 60FPS (1/60 ~= 0.01666)ï¼Œä½¿ç”¨å€ç‡ä¾†èª¿æ•´é€Ÿåº¦
        const timeScale = dt * 60; 

        if (state.isGiftScene) {
            renderer.render(scene, camera);
            return;
        }

        let deltaRotation = 0;
        if (mainGroup) {
            const currentRotation = mainGroup.rotation.y;
            deltaRotation = currentRotation - state.previousRotationY;
            state.previousRotationY = currentRotation;
        }

        if (!state.isDragging) {
            // ä½¿ç”¨ timeScale å¹³æ»‘é€Ÿåº¦è®ŠåŒ–
            state.currentRotationSpeed +=
                (state.targetRotationSpeed - state.currentRotationSpeed) * 0.05 * timeScale;
            
            if (mainGroup) {
                // ä½¿ç”¨ timeScale èª¿æ•´æ—‹è½‰é€Ÿåº¦
                mainGroup.rotation.y += state.currentRotationSpeed * timeScale;
            }
        }

        const t = Date.now() * 0.005;
        flames.forEach((f) => {
            f.mesh.scale.set(
                1,
                Math.sin(t * f.spd + f.off) * 0.2 + 0.8,
                1
            );
        });

        state.smoothedDeltaRotation +=
            (deltaRotation - state.smoothedDeltaRotation) * 0.1 * timeScale;
        
        // ç…™ç«æ›´æ–°ä¹Ÿéœ€è¦åŸºæ–¼ timeScaleï¼Œé€™è£¡ç°¡åŒ–è™•ç†ï¼Œå› ç‚º update å…§éƒ¨æ˜¯åŸºæ–¼ globalTime
        state.fireworkGlobalTime += state.smoothedDeltaRotation * 150;
        
        // æ³¨æ„ï¼šFirework å…§éƒ¨çš„ update æ˜¯åŸºæ–¼æ™‚é–“æˆ³è¨˜çš„ï¼Œæ‰€ä»¥ä¸éœ€è¦é¡å¤–ä¹˜ timeScale
        // ä½†æ˜¯è§¸ç™¼é »ç‡å—åˆ°äº† fireworkGlobalTime å½±éŸ¿ï¼Œé€™å·²ç¶“è¢« deltaRotation é–“æ¥ä¿®æ­£äº†
        fireworks.forEach((fw) => fw.update(state.fireworkGlobalTime));

        renderer.render(scene, camera);
    }

    // è¦–çª—å¤§å°æ”¹è®Šæ™‚ï¼Œæ›´æ–°ç›¸æ©Ÿå’Œæ¸²æŸ“å™¨
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // DOM åŠ è¼‰å®Œæˆå¾Œï¼Œåˆå§‹åŒ–ä¸¦è¨­ç½®äº’å‹•
    window.addEventListener("DOMContentLoaded", () => {
        init();
        setupInteraction();
        // åˆå§‹ç‹€æ…‹ï¼šç§»é™¤ floating textï¼Œå› ç‚ºå·²ç¶“ç”± subtitle å–ä»£
    });
})();
</script>
</body>
</html>
